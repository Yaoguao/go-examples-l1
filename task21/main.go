package main

import (
	"fmt"
	"time"
)

//	TASK 21

/*
Паттерн «Адаптер»
Реализовать паттерн проектирования «Адаптер» на любом примере.

Описание: паттерн Adapter позволяет сконвертировать интерфейс одного класса в интерфейс другого, который ожидает клиент.

Продемонстрируйте на простом примере в Go: у вас есть существующий интерфейс (или структура)
и другой, несовместимый по интерфейсу потребитель — напишите адаптер,
который реализует нужный интерфейс и делегирует вызовы к встроенному объекту.

Поясните применимость паттерна, его плюсы и минусы, а также приведите реальные примеры использования.
*/

// реальный пример
type Logger interface {
	DEBUG(text string)
}

type IExternalLogger interface {
	WriteText(level, text string)
}

// Представим у нас есть логгер из другой библиотеки
type ExternalLogger struct {
}

// Его функция
func (l *ExternalLogger) WriteText(level, text string) {
	timeNow := time.Now().Format("2006-01-02 15:04:05")
	fmt.Printf("%s LOG %s %s", timeNow, level, text)
}

// И тут мы реализуем сам адаптер, который позволит нам использовать логгер с абсолютно разным интерфейсом
type LoggerAdapter struct {
	elog *ExternalLogger
}

// Реализуем функция нашего интерфейса
func (l *LoggerAdapter) DEBUG(text string) {
	l.elog.WriteText("DEBUG", text)
}

func foo(log Logger) {
	log.DEBUG("text bla bla")
}

//  Если говорить о плюсах и минусах
//	+
//	Мы выполняем один из приципов SOLID - Принцип открытости/закрытости
//	Как было в описания задачи - совместимость несовместимых интерфейсов
//	И можно переиспользовать много раз один код
//	-
//	Более сложная структура

func main() {
	log := &LoggerAdapter{
		elog: &ExternalLogger{},
	}
	foo(log)
}
